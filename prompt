##################################################################### CONFIG
	default_user=lvv 		# default user is not displayed
	default_host="ahp"      # default host is not displayed
	default_domain="lvvnet"	# default domain is not deplayed, remote host is alwais shown

    # dir, rc, root color 
	if [ "`tput colors`" -ge 8 ];  then				#  if terminal supports colors
		dir_color='CYAN'
		rc_color='red'
		root_id_color='magenta'
	else											#  only B/W
		dir_color='bw_bold'
		rc_color='bw_bold'
	fi

                                                    # where is user color?

    # per host color
    TOSHA_host_color='yellow'
    TASHA_host_color='cyan'
       AL_host_color='green'
       SH_host_color='blue'
      LVV_host_color='blue'
      AHP_host_color='white'

    # git state colors
    git_clean=blue         # nothing to commit (working directory clean)
    git_modified=red       # # Changed but not updated:
    git_added=green        # # Changes to be committed:
    git_mixed=yellow       # 
    git_untracked=BLUE     # # Untracked files:
    git_op=MAGENTA         

#####################################################################  post config

	######################################## terminfo colors
	#
	#   black?    0	8			  
	#	red       1 9
	#	green     2 10
	#	yellow    3 11
	#	blue      4 12
	#	magenta   5 13
	#	cyan      6 14
	#	white     7 15
	#
	#	terminfo setaf/setab - sets ansi foreground/background
	#	terminfo sgr0 - resets all atributes
	#	terminfo colors - number of colors

	### if term support colors,  then use color prompt, else bold

              black='\['`tput sgr0; tput setaf 0`'\]'
                red='\['`tput sgr0; tput setaf 1`'\]'
              green='\['`tput sgr0; tput setaf 2`'\]'
             yellow='\['`tput sgr0; tput setaf 3`'\]'
               blue='\['`tput sgr0; tput setaf 4`'\]'
            magenta='\['`tput sgr0; tput setaf 5`'\]'
               cyan='\['`tput sgr0; tput setaf 6`'\]'
              white='\['`tput sgr0; tput setaf 7`'\]'

              BLACK='\['`tput setaf 0; tput bold`'\]'
                RED='\['`tput setaf 1; tput bold`'\]'
              GREEN='\['`tput setaf 2; tput bold`'\]'
             YELLOW='\['`tput setaf 3; tput bold`'\]'
               BLUE='\['`tput setaf 4; tput bold`'\]'
            MAGENTA='\['`tput setaf 5; tput bold`'\]'
               CYAN='\['`tput setaf 6; tput bold`'\]'  # why 14 dosn't work?
              WHITE='\['`tput setaf 7; tput bold`'\]'

            bw_bold='\['`tput bold`'\]'
               bell=`tput bel`

       colors_reset='\['`tput sgr0`'\]'

	# Workaround for UTF readline(?) bug. Dissable bell when UTF
	locale |grep -qi UTF && bell=''	


    # replace symbolic colors names to raw treminfo strings
    git_modified=${!git_modified}
    git_untracked=${!git_untracked}
    git_clean=${!git_clean}
    git_added=${!git_added}
    git_op=${!git_op}
    git_mixed=${!git_mixed}

##################################################################### 
    LC_ALL=C
	# if label non empty, append 1 space
	label=${1:+$1 }


	# echo "*** /etc/prompt  on A,  TERM=$TERM"
	unset PROMPT_COMMAND

	#######  work aroud for MC bug
	if [ -z "$TERM" -o "$TERM" = "dumb" -o -n "$MC_SID" ]; then
		unset PROMPT_COMMAND
		PS1='\w> '
		return 0
	fi

	export who_where


set_shell_title() { 

	xterm_title() { echo  -n "]2;${@}" ; }

	screen_title() { 
		# FIXME: run this only if screen is in xterm (how to test for this?)
		xterm_title  "sCRn  $label$plain_who_where $@" 

		# FIXME $STY not enherited though "su -"
		[ "$STY" ] && screen -S $STY -X title "$@"
	}

	case $TERM in

		screen*)                                                    
			screen_title "$@"
			;;

		xterm* | rxvt* | gnome-terminal | konsole | eterm | wterm )       
			# is there a capability which we can to test 
			# for "set term title-bat" and its escapes?
			#echo -n "]2;$label$plain_who_where $1"
			xterm_title  "$label$plain_who_where $@"
			;;

		*)                                                     
			;;
	esac
}

export -f set_shell_title

###################################################### ID (user name)
	id=`id -un`
	id=${id#$default_user}

###################################################### TTY
	tty=`tty`
	tty=`echo $tty | sed "s:/dev/pts/:p:; s:/dev/tty::" `		# RH tty devs	
	tty=`echo $tty | sed "s:/dev/vc/:vc:" `				# gentoo tty devs

	if [[ "$TERM" = "screen" ]] ;  then

		#	[ "$WINDOW" = "" ] && WINDOW="?"
		#	
		#		# if under screen then make tty name look like s1-p2
		#		# tty="${WINDOW:+s}$WINDOW${WINDOW:+-}$tty"
		#	tty="${WINDOW:+s}$WINDOW"  # replace tty name with screen number
		tty="$WINDOW"  # replace tty name with screen number
	fi

	# we don't need tty name under X11
	case $TERM in
		xterm* | rxvt* | gnome-terminal | konsole | eterm | wterm )  unset tty ;;
		*)		                                                              ;;
	esac


    dir_color=${!dir_color}
    rc_color=${!rc_color}
    root_id_color=${!root_id_color}


	########################################################### HOST
	### we don't display home host/domain  $SSH_* set by SSHD or keychain

    # I give up.  How to find out if session is local or remote? Working with "su -", ssh-agent, and so on ? 
	## is sshd our perent?
	# if 	{ for ((pid=$$; $pid != 1 ; pid=`ps h -o pid --ppid $pid`)); do ps h -o command -p $pid; done | grep -q sshd }
	#then 
		host=${HOSTNAME}
		#host=`hostname --short`
		host=`echo ${host%$default_host} | tr a-z A-Z`
		#host=`echo ${host} | tr a-z A-Z`
        host_color=${host}_host_color
        host_color=${!host_color}
	#else
	#	host=""
	#fi 

    host_color=${!host_color}

	# we already should have short host name, but just in case
	host=${host%.localdoman}
	host=${host%.$default_domain}


########################################################### WHO_WHERE 
# who_ware. Is constant.  Looks like
# 	[user@]host[-tty]

color_who_where="${id:+$id@}$host_color$host${tty:+ $tty}"
plain_who_where="${id:+$id@}$host"

# remove trailing "@" if any
color_who_where="${color_who_where%@}"
plain_who_where="${plain_who_where%@}"

# add traling " "
color_who_where="$color_who_where "
plain_who_where="$plain_who_where "

# if  $who_where==" "  then  who_where=""
color_who_where="${color_who_where## }"
plain_who_where="${plain_who_where## }"


# if root then highlight who_where
if	[ "$id" == "root" ]  ; then 
	color_who_where="$root_id_color$color_who_where$colors_reset"
fi


############################################################### PROMPT_COMMAND

PROMPT_COMMAND='

	rc="$?"

	if [[ "$rc" = "0" ]]; then 
		rc=""
	else
		#rc="$rc_color$rc$colors_reset$bell "
		rc="$rc_color$rc$colors_reset "
	fi

	set_shell_title "$PWD/" 

	# truncate $PWD to $max
		max=35
		front=7
		head=${PWD:0:$front}"..."

    # LOCALS
        # SVN 
        # ...
       
        # make
        # ...
        
        # GIT 
            git_dir=`git-rev-parse --git-dir 2> /dev/null`
            if [[ $git_dir ]];   then

                eval `git status |
                        sed -n "
                            s/^# On branch /branch=/p

                            s/^nothing to commit (working directory clean)/clean=clean/p

                            /^# Untracked files:/,/^[^#]/{
                                s/^#	/git_untracked_files+=\" \"/p   
                                s/^# Untracked files:/untracked=untracked/p
                            }

                            /^# Changed but not updated:/,/^# [A-Z]/ {
                                s/^# Changed but not updated:/modified=modified/p
                                s/#	modified:   /git_modified_files+=\" \"/p
                            }

                            /^# Changes to be committed:/,/^# [A-Z]/ {
                                s/^# Changes to be committed:/added=added/p
                                s/^#	modified:   /git_added_files+=\" \"/p
                                s/^#	new file:   /git_added_files+=\" \"/p
                            }
                        " 
                `

                ### OP 
                unset op
                
                if [[ -d "$git_dir/.dotest" ]] ;  then

                    if [[ -f "$git_dir/.dotest/rebasing" ]] ;  then
                        op="rebase"

                    elif [[ -f "$git_dir/.dotest/applying" ]] ; then
                        op="am"

                    else
                        op="am/rebase"

                    fi

                elif  [[ -f "$git_dir/.dotest-merge/interactive" ]] ;  then
                    op="rebase -i"
                    # ??? branch="$(cat "$git_dir/.dotest-merge/head-name")"

                elif  [[ -d "$git_dir/.dotest-merge" ]] ;  then
                    op="rebase -m"
                    # ??? branch="$(cat "$git_dir/.dotest-merge/head-name")"
                    
                elif  [[ -f "$git_dir/MERGE_HEAD" ]] ;  then
                    op="merge"
                    # ??? branch="$(git symbolic-ref HEAD 2>/dev/null)"
                    
                else
                    [[  -f "$git_dir/BISECT_LOG"  ]]   &&  op="bisect"
                    # ??? branch="$(git symbolic-ref HEAD 2>/dev/null)" || \
                    #    branch="$(git describe --exact-match HEAD 2>/dev/null)" || \
                    #    branch="$(cut -c1-7 "$git_dir/HEAD")..."
                fi

             
                ### sort statuses, choose primary (for branch color)
                status=${op+op}
                status=${status:-$clean}
                status=${status:-$modified}
                status=${status:-$added}
                status=${status:-$untracked}
                                        # at least one should be set
                                        : ${status?prompt internal error: git status}
                eval git_color="\${git_$status}"
                git_color=${git_color:-$WHITE}

                ### head
                head=`git-name-rev --name-only HEAD 2>/dev/null`
                head_rev=`git-rev-parse HEAD 2>/dev/null`
                head_rev=${head_rev/HEAD/}
                head_rev=${head_rev:0:6}

                ### compose local label
                
                unset file_list
                file_list+="${git_added_files+$git_added$git_added_files }"
                file_list+="${git_modified_files+$git_modified$git_modified_files }"
                file_list+="${git_untracked_files+$git_untracked$git_untracked_files }"
                [[ $file_list ]] && file_list=":${file_list}"          # ${+  does not works (?)
                tail_local="(${head/master/m} $white$head_rev$git_color${op+ / $op}$git_color${file_list}$git_color)"

                ### fringes (added depended on location)
                head_local="${head_local+$git_color $head_local\n}"
                tail_local="${tail_local+$git_color $tail_local}${dir_color}"

                unset  branch status git_color clean added modified untracked sep file_list
                unset  git_modified_files
                unset  git_untracked_files 
                unset  git_added_files 
            fi 
    #########################
    

	# PS1="$label$rc'$color_who_where$dir_color'${head:10*(${#PWD}<max)}${PWD:(${#PWD}>max)*(${#PWD}-max):max}> '$colors_reset'"
    
	PS1="$head_local$colors_reset$label$rc'$color_who_where$dir_color'\w$tail_local'$dir_color'> '$colors_reset'"

    unset head_local tail_local
'
#echo \"$color_who_where\"
unset rc id tty bell default_user default_host
unset rc_colors dir_color root_id_color 

# vim: set syntax=sh:
